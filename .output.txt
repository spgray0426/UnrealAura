diff --git a/Source/Aura/Private/AbilitySystem/AuraAttributeSet.cpp b/Source/Aura/Private/AbilitySystem/AuraAttributeSet.cpp
index 491309e..00d1a8c 100644
--- a/Source/Aura/Private/AbilitySystem/AuraAttributeSet.cpp
+++ b/Source/Aura/Private/AbilitySystem/AuraAttributeSet.cpp
@@ -3,6 +3,9 @@

 #include "AbilitySystem/AuraAttributeSet.h"

+#include "AbilitySystemBlueprintLibrary.h"
+#include "GameplayEffectExtension.h"
+#include "GameFramework/Character.h"
 #include "Net/UnrealNetwork.h"

 UAuraAttributeSet::UAuraAttributeSet()
@@ -22,6 +25,59 @@ void UAuraAttributeSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& Ou
        DOREPLIFETIME_CONDITION_NOTIFY(ThisClass, MaxMana, COND_None, REPNOTIFY_Always);
 }

+void UAuraAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
+{
+       Super::PreAttributeChange(Attribute, NewValue);
+
+       if (Attribute == GetHealthAttribute())
+       {
+               NewValue = FMath::Clamp(NewValue, 0.f, GetMaxHealth());
+       }
+       if (Attribute == GetManaAttribute())
+       {
+               NewValue = FMath::Clamp(NewValue, 0.f, GetMaxMana());
+       }
+}
+
+void UAuraAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)
+{
+       Super::PostGameplayEffectExecute(Data);
+
+       FEffectProperties Props;
+       SetEffectProperties(Data, Props);
+}
+
+void UAuraAttributeSet::SetEffectProperties(const FGameplayEffectModCallbackData& Data, FEffectProperties& Props) const
+{
+       Props.EffectContextHandle = Data.EffectSpec.GetContext();
+       Props.SourceASC = Props.EffectContextHandle.GetOriginalInstigatorAbilitySystemComponent();
+
+       if (IsValid(Props.SourceASC) && Props.SourceASC->AbilityActorInfo.IsValid() && Props.SourceASC->AbilityActorInfo->AvatarActor.IsValid())
+       {
+               Props.SourceAvatarActor = Props.SourceASC->AbilityActorInfo->AvatarActor.Get();
+               Props.SourceController = Props.SourceASC->AbilityActorInfo->PlayerController.Get();
+               if (Props.SourceController == nullptr && Props.SourceAvatarActor != nullptr)
+               {
+                       if (const APawn* Pawn = Cast<APawn>(Props.SourceAvatarActor))
+                       {
+                               Props.SourceController = Pawn->GetController();
+                       }
+               }
+               if (Props.SourceController)
+               {
+                       Props.SourceCharacter = Cast<ACharacter>(Props.SourceController->GetPawn());
+               }
+       }
+
+       if (Data.Target.AbilityActorInfo.IsValid() && Data.Target.AbilityActorInfo->AvatarActor.IsValid())
+       {
+               Props.TargetAvatarActor = Data.Target.AbilityActorInfo->AvatarActor.Get();
+               Props.TargetController = Data.Target.AbilityActorInfo->PlayerController.Get();
+               Props.TargetCharacter = Cast<ACharacter>(Props.TargetAvatarActor);
+               Props.TargetASC = &Data.Target;
+       }
+}
+
 void UAuraAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth) const
 {
        GAMEPLAYATTRIBUTE_REPNOTIFY(ThisClass, Health, OldHealth);
diff --git a/Source/Aura/Public/AbilitySystem/AuraAttributeSet.h b/Source/Aura/Public/AbilitySystem/AuraAttributeSet.h
index f41a392..de86402 100644
--- a/Source/Aura/Public/AbilitySystem/AuraAttributeSet.h
+++ b/Source/Aura/Public/AbilitySystem/AuraAttributeSet.h
@@ -13,6 +13,39 @@ GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
 GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
 GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

+USTRUCT()
+struct FEffectProperties
+{
+       GENERATED_BODY()
+
+       FEffectProperties(){}
+
+       FGameplayEffectContextHandle EffectContextHandle;
+
+       UPROPERTY()
+       UAbilitySystemComponent* SourceASC {};
+
+       UPROPERTY()
+       AActor* SourceAvatarActor {};
+
+       UPROPERTY()
+       AController* SourceController {};
+
+       UPROPERTY()
+       ACharacter* SourceCharacter {};
+
+       UPROPERTY()
+       UAbilitySystemComponent* TargetASC {};
+
+       UPROPERTY()
+       AActor* TargetAvatarActor {};
+
+       UPROPERTY()
+       AController* TargetController {};
+
+       UPROPERTY()
+       ACharacter* TargetCharacter {};
+};
 /**
  *
  */
@@ -24,6 +57,8 @@ class AURA_API UAuraAttributeSet : public UAttributeSet
 public:
        UAuraAttributeSet();
        virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
+       virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
+       virtual void PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data) override;

        UPROPERTY(BlueprintReadOnly ,ReplicatedUsing = OnRep_Health, Category = "Vital Attributes")
        FGameplayAttributeData Health;
@@ -54,4 +89,8 @@ public:

        UFUNCTION()
        void OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana) const;
+
+private:
+
+       void SetEffectProperties(const FGameplayEffectModCallbackData& Data, FEffectProperties& Props) const;
 };
diff --git a/Source/Aura/Private/Actor/AuraEffectActor.cpp b/Source/Aura/Private/Actor/AuraEffectActor.cpp
index c4e66f1..527d530 100644
--- a/Source/Aura/Private/Actor/AuraEffectActor.cpp
+++ b/Source/Aura/Private/Actor/AuraEffectActor.cpp
@@ -3,6 +3,7 @@

 #include "Actor/AuraEffectActor.h"

+#include "AbilitySystemBlueprintLibrary.h"
 #include "AbilitySystemInterface.h"
 #include "AbilitySystem/AuraAttributeSet.h"
 #include "Components/SphereComponent.h"
@@ -12,38 +13,83 @@ AAuraEffectActor::AAuraEffectActor()
 {
        PrimaryActorTick.bCanEverTick = false;

-       Mesh = CreateDefaultSubobject<UStaticMeshComponent>("Mesh");
-       SetRootComponent(Mesh);
+       SetRootComponent(CreateDefaultSubobject<USceneComponent>("SceneRoot"));
+}
+

-       Sphere = CreateDefaultSubobject<USphereComponent>("Sphere");
-       Sphere->SetupAttachment(GetRootComponent());
+void AAuraEffectActor::BeginPlay()
+{
+       Super::BeginPlay();
 }

-void AAuraEffectActor::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
-       UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
+void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf<UGameplayEffect> GameplayEffectClass)
 {
-       //TODO: Change this to apply a Gameplay Effect. For now, using const_cast as a hack!
-       if (IAbilitySystemInterface* ASCInterface = Cast<IAbilitySystemInterface>(OtherActor))
-       {
-               const UAuraAttributeSet* AuraAttributeSet = Cast<UAuraAttributeSet>(ASCInterface->GetAbilitySystemComponent()->GetAttributeSet(UAuraAttributeSet::StaticClass()));
+       UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor);
+       if (!IsValid(TargetASC)) return;
+
+       check(GameplayEffectClass);
+       FGameplayEffectContextHandle EffectContextHandle = TargetASC->MakeEffectContext();
+       EffectContextHandle.AddSourceObject(this);
+       const FGameplayEffectSpecHandle EffectSpecHandle = TargetASC->MakeOutgoingSpec(GameplayEffectClass, ActorLevel, EffectContextHandle);
+
+       const FActiveGameplayEffectHandle ActiveEffectHandle = TargetASC->ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get());

-               UAuraAttributeSet* MutableAuraAttributeSet = const_cast<UAuraAttributeSet*>(AuraAttributeSet);
-               MutableAuraAttributeSet->SetHealth(AuraAttributeSet->GetHealth() + 25.f);
-               MutableAuraAttributeSet->SetMana(AuraAttributeSet->GetMana() - 25.f);
-               Destroy();
+       const bool bIsInfinite =  EffectSpecHandle.Data.Get()->Def.Get()->DurationPolicy == EGameplayEffectDurationType::Infinite;
+
+       if (bIsInfinite && InfiniteEffectRemovalPolicy == EEffectRemovalPolicy::RemoveOnEndOverlap)
+       {
+               ActiveEffectHandles.Add(ActiveEffectHandle, TargetASC);
        }
 }

-void AAuraEffectActor::EndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
-       UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
+void AAuraEffectActor::OnOverlap(AActor* TargetActor)
 {
-
+       if (InstantEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnOverlap)
+       {
+               ApplyEffectToTarget(TargetActor, InstantGameplayEffectClass);
+       }
+       if (DurationEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnOverlap)
+       {
+               ApplyEffectToTarget(TargetActor, DurationGameplayEffectClass);
+       }
+       if (InfiniteEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnOverlap)
+       {
+               ApplyEffectToTarget(TargetActor, InfiniteGameplayEffectClass);
+       }
 }

-void AAuraEffectActor::BeginPlay()
+void AAuraEffectActor::OnEndOverlap(AActor* TargetActor)
 {
-       Super::BeginPlay();
+       if (InstantEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnEndOverlap)
+       {
+               ApplyEffectToTarget(TargetActor, InstantGameplayEffectClass);
+       }
+       if (DurationEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnEndOverlap)
+       {
+               ApplyEffectToTarget(TargetActor, DurationGameplayEffectClass);
+       }
+       if (InfiniteEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnEndOverlap)
+       {
+               ApplyEffectToTarget(TargetActor, InfiniteGameplayEffectClass);
+       }
+
+       if (InfiniteEffectRemovalPolicy == EEffectRemovalPolicy::RemoveOnEndOverlap)
+       {
+               UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor);
+               if (!IsValid(TargetASC)) return;

-       Sphere->OnComponentBeginOverlap.AddDynamic(this, &AAuraEffectActor::OnOverlap);
-       Sphere->OnComponentEndOverlap.AddDynamic(this, &AAuraEffectActor::EndOverlap);
+               TArray<FActiveGameplayEffectHandle> HandlesToRemove;
+               for (auto& HandlePair : ActiveEffectHandles)
+               {
+                       if (TargetASC == HandlePair.Value)
+                       {
+                               TargetASC->RemoveActiveGameplayEffect(HandlePair.Key, 1);
+                               HandlesToRemove.Add(HandlePair.Key);
+                       }
+               }
+               for (FActiveGameplayEffectHandle& Handle : HandlesToRemove)
+               {
+                       ActiveEffectHandles.FindAndRemoveChecked(Handle);
+               }
+       }
 }
diff --git a/Source/Aura/Public/Actor/AuraEffectActor.h b/Source/Aura/Public/Actor/AuraEffectActor.h
index 2060f65..5718482 100644
--- a/Source/Aura/Public/Actor/AuraEffectActor.h
+++ b/Source/Aura/Public/Actor/AuraEffectActor.h
@@ -3,11 +3,30 @@
 #pragma once

 #include "CoreMinimal.h"
+#include "ActiveGameplayEffectHandle.h"
+
 #include "GameFramework/Actor.h"
 #include "AuraEffectActor.generated.h"

+class UAbilitySystemComponent;
+class UGameplayEffect;
 class USphereComponent;

+UENUM(BlueprintType)
+enum class EEffectApplicationPolicy : uint8
+{
+       ApplyOnOverlap,
+       ApplyOnEndOverlap,
+       DoNotApply
+};
+
+UENUM(BlueprintType)
+enum class EEffectRemovalPolicy : uint8
+{
+       RemoveOnEndOverlap,
+       DoNotRemove
+};
+
 UCLASS()
 class AURA_API AAuraEffectActor : public AActor
 {
@@ -16,17 +35,48 @@ class AURA_API AAuraEffectActor : public AActor
 public:
        AAuraEffectActor();

-       UFUNCTION()
-       virtual void OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
-
-       UFUNCTION()
-       virtual void EndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
+
 protected:
        virtual void BeginPlay() override;
-private:
-       UPROPERTY(VisibleAnywhere)
-       TObjectPtr<USphereComponent> Sphere;
+
+       UFUNCTION(BlueprintCallable)
+       void ApplyEffectToTarget(AActor* TargetActor, TSubclassOf<UGameplayEffect> GameplayEffectClass);
+
+       UFUNCTION(BlueprintCallable)
+       void OnOverlap(AActor* TargetActor);
+
+       UFUNCTION(BlueprintCallable)
+       void OnEndOverlap(AActor* TargetActor);
+
+       UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Applied Effects")
+       bool bDestroyOnEffectRemoval {false};
+
+       UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Applied Effects")
+       float ActorLevel {1.f};
+
+       UPROPERTY()
+       TMap<FActiveGameplayEffectHandle, UAbilitySystemComponent*> ActiveEffectHandles;
+
+       UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Applied Effects" )
+       TSubclassOf<UGameplayEffect> InstantGameplayEffectClass;
+
+       UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Applied Effects")
+       EEffectApplicationPolicy InstantEffectApplicationPolicy {EEffectApplicationPolicy::DoNotApply};
+
+       UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Applied Effects")
+       TSubclassOf<UGameplayEffect> DurationGameplayEffectClass;
+
+       UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Applied Effects")
+       EEffectApplicationPolicy DurationEffectApplicationPolicy {EEffectApplicationPolicy::DoNotApply};
+
+       UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Applied Effects")
+       TSubclassOf<UGameplayEffect> InfiniteGameplayEffectClass;
+
+       UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Applied Effects")
+       EEffectApplicationPolicy InfiniteEffectApplicationPolicy {EEffectApplicationPolicy::DoNotApply};

-       UPROPERTY(VisibleAnywhere)
-       TObjectPtr<UStaticMeshComponent> Mesh;
+       UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Applied Effects")
+       EEffectRemovalPolicy InfiniteEffectRemovalPolicy {EEffectRemovalPolicy::RemoveOnEndOverlap};
+
+
 };