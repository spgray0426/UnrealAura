diff --git a/Source/Aura/Private/AbilitySystem/AuraAbilitySystemComponent.cpp b/Source/Aura/Private/AbilitySystem/AuraAbilitySystemComponent.cpp
index fcee187..2b829c3 100644
--- a/Source/Aura/Private/AbilitySystem/AuraAbilitySystemComponent.cpp
+++ b/Source/Aura/Private/AbilitySystem/AuraAbilitySystemComponent.cpp
@@ -8,7 +8,7 @@

 void UAuraAbilitySystemComponent::AbilityActorInfoSet()
 {
-       OnGameplayEffectAppliedDelegateToSelf.AddUObject(this, &ThisClass::EffectApplied);
+       OnGameplayEffectAppliedDelegateToSelf.AddUObject(this, &ThisClass::ClientEffectApplied);
 }

 void UAuraAbilitySystemComponent::AddCharacterAbilities(const TArray<TSubclassOf<UGameplayAbility>>& StartupAbilities)
@@ -55,7 +55,7 @@ void UAuraAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& In
        }
 }

-void UAuraAbilitySystemComponent::EffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
+void UAuraAbilitySystemComponent::ClientEffectApplied_Implementation(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)
 {
        FGameplayTagContainer TagContainer;
        EffectSpec.GetAllAssetTags(TagContainer);
diff --git a/Source/Aura/Private/Character/AuraCharacterBase.cpp b/Source/Aura/Private/Character/AuraCharacterBase.cpp
index 58acf96..4b9ddfe 100644
--- a/Source/Aura/Private/Character/AuraCharacterBase.cpp
+++ b/Source/Aura/Private/Character/AuraCharacterBase.cpp
@@ -29,6 +29,12 @@ void AAuraCharacterBase::BeginPlay()

 }

+FVector AAuraCharacterBase::GetCombatSocketLocation()
+{
+       check(Weapon);
+       return Weapon->GetSocketLocation(WeaponTipSocketName);
+}
+
 void AAuraCharacterBase::ApplyEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass, float Level) const
 {
        check(IsValid(GetAbilitySystemComponent()));
diff --git a/Source/Aura/Private/Interaction/CombatInterface.cpp b/Source/Aura/Private/Interaction/CombatInterface.cpp
index 6e4faf9..b12b079 100644
--- a/Source/Aura/Private/Interaction/CombatInterface.cpp
+++ b/Source/Aura/Private/Interaction/CombatInterface.cpp
@@ -8,4 +8,9 @@
 int32 ICombatInterface::GetPlayerLevel()
 {
        return 0;
-}
\ No newline at end of file
+}
+
+FVector ICombatInterface::GetCombatSocketLocation()
+{
+       return FVector();
+}
diff --git a/Source/Aura/Private/Player/AuraPlayerController.cpp b/Source/Aura/Private/Player/AuraPlayerController.cpp
index cf3e7e8..1e846f3 100644
--- a/Source/Aura/Private/Player/AuraPlayerController.cpp
+++ b/Source/Aura/Private/Player/AuraPlayerController.cpp
@@ -4,9 +4,13 @@
 #include "Player/AuraPlayerController.h"

 #include "AbilitySystemBlueprintLibrary.h"
+#include "AuraGameplayTags.h"
 #include "EnhancedInputComponent.h"
 #include "EnhancedInputSubsystems.h"
+#include "NavigationPath.h"
+#include "NavigationSystem.h"
 #include "AbilitySystem/AuraAbilitySystemComponent.h"
+#include "Components/SplineComponent.h"
 #include "Input/AuraInputComponent.h"
 #include "Interaction/EnemyInterface.h"

@@ -14,6 +18,8 @@
 AAuraPlayerController::AAuraPlayerController()
 {
        bReplicates = true;
+
+       Spline = CreateDefaultSubobject<USplineComponent>("Spline");
 }


@@ -52,6 +58,7 @@ void AAuraPlayerController::PlayerTick(float DeltaTime)
        Super::PlayerTick(DeltaTime);

        CursorTrace();
+       AutoRun();
 }

 UAuraAbilitySystemComponent* AAuraPlayerController::GetASC()
@@ -65,69 +72,120 @@ UAuraAbilitySystemComponent* AAuraPlayerController::GetASC()

 void AAuraPlayerController::CursorTrace()
 {
-       FHitResult CursorHit;
+
        GetHitResultUnderCursor(ECC_Visibility, false, CursorHit);
        if (!CursorHit.bBlockingHit) return;

        LastActor = ThisActor;
        ThisActor = CursorHit.GetActor();

-       /**
-        * Line trace from cursor. There are several scenarios:
-        *  A. LastActor is null && ThisActor is null
-        *              - Do nothing
-        *      B. LastActor is null && ThisActor is valid
-        *              - Highlight ThisActor
-        *      C. LastActor is valid && ThisActor is null
-        *              - UnHighlight LastActor
-        *      D. Both actors are valid, but LastActor != ThisActor
-        *              - UnHighlight LastActor, and Highlight ThisActor
-        *      E. Both actors are valid, and are the same actor
-        *              - Do nothing
-        */
-
-       if (LastActor == nullptr)
+       if (LastActor != ThisActor)
+       {
+               if (LastActor) LastActor->UnHighlightActor();
+               if (ThisActor) ThisActor->HighlightActor();
+       }
+}
+
+void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
+{
+       if (InputTag.MatchesTagExact(FAuraGameplayTags::Get().InputTag_RMB))
+       {
+               bTargeting = ThisActor ? true : false;
+               bAutoRunning = false;
+       }
+}
+
+void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
+{
+       if (!InputTag.MatchesTagExact(FAuraGameplayTags::Get().InputTag_RMB))
        {
-               if (ThisActor != nullptr)
+               if (GetASC())
                {
-                       // Case B
-                       ThisActor->HighlightActor();
+                       GetASC()->AbilityInputTagReleased(InputTag);
                }
+               return;
        }
-       else // LastActor is valid
+
+       if (bTargeting)
        {
-               if (ThisActor == nullptr)
+               if (GetASC())
                {
-                       // Case C
-                       LastActor->UnHighlightActor();
+                       GetASC()->AbilityInputTagReleased(InputTag);
                }
-               else // both actors are valid
+       }
+       else
+       {
+               const APawn* ControlledPawn = GetPawn();
+               if (FollowTime <= ShortPressThreshold && ControlledPawn)
                {
-                       if (LastActor != ThisActor)
+                       if (UNavigationPath* NavPath = UNavigationSystemV1::FindPathToLocationSynchronously(this, ControlledPawn->GetActorLocation(), CachedDestination))
                        {
-                               // Case D
-                               LastActor->UnHighlightActor();
-                               ThisActor->HighlightActor();
+                               Spline->ClearSplinePoints();
+                               for (const FVector& PointLoc : NavPath->PathPoints)
+                               {
+                                       Spline->AddSplinePoint(PointLoc, ESplineCoordinateSpace::World);
+                               }
+                               CachedDestination = NavPath->PathPoints[NavPath->PathPoints.Num() - 1];
+                               bAutoRunning = true;
                        }
                }
+               FollowTime = 0.f;
+               bTargeting = false;
        }
 }

-void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
+void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
 {
-       //GEngine->AddOnScreenDebugMessage(1, 3.f, FColor::Red, *InputTag.ToString());
-}
+       // LMB로 고정하는건 별로 좋은 생각이 아닌거 같긴한데
+       if (!InputTag.MatchesTagExact(FAuraGameplayTags::Get().InputTag_RMB))
+       {
+               if (GetASC())
+               {
+                       GetASC()->AbilityInputTagHeld(InputTag);
+               }
+               return;
+       }

-void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
-{
-       if (GetASC() == nullptr) return;
-       GetASC()->AbilityInputTagReleased(InputTag);
+       if (bTargeting)
+       {
+               if (GetASC())
+               {
+                       GetASC()->AbilityInputTagHeld(InputTag);
+               }
+       }
+       else
+       {
+               FollowTime += GetWorld()->GetDeltaSeconds();
+
+
+               if (CursorHit.bBlockingHit)
+               {
+                       CachedDestination = CursorHit.ImpactPoint;
+               }
+
+               if (APawn* ControlledPawn = GetPawn())
+               {
+                       const FVector WorldDirection = (CachedDestination - ControlledPawn->GetActorLocation()).GetSafeNormal();
+                       ControlledPawn->AddMovementInput(WorldDirection);
+               }
+       }
 }

-void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
+void AAuraPlayerController::AutoRun()
 {
-       if (GetASC() == nullptr) return;
-       GetASC()->AbilityInputTagHeld(InputTag);
+       if (!bAutoRunning) return;
+       if (APawn* ControlledPawn = GetPawn())
+       {
+               const FVector LocationOnSpline = Spline->FindLocationClosestToWorldLocation(ControlledPawn->GetActorLocation(), ESplineCoordinateSpace::World);
+               const FVector Direction = Spline->FindDirectionClosestToWorldLocation(LocationOnSpline, ESplineCoordinateSpace::World);
+               ControlledPawn->AddMovementInput(Direction);
+
+               const float DistanceToDestination = (LocationOnSpline - CachedDestination).Length();
+               if (DistanceToDestination <= AutoRunAcceptanceRadius)
+               {
+                       bAutoRunning = false;
+               }
+       }
 }


diff --git a/Source/Aura/Public/AbilitySystem/AuraAbilitySystemComponent.h b/Source/Aura/Public/AbilitySystem/AuraAbilitySystemComponent.h
index 64b54d4..c28f4d4 100644
--- a/Source/Aura/Public/AbilitySystem/AuraAbilitySystemComponent.h
+++ b/Source/Aura/Public/AbilitySystem/AuraAbilitySystemComponent.h
@@ -24,6 +24,7 @@ public:
        FEffectAssetTags EffectAssetTags;
 protected:

-       void EffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);
+       UFUNCTION(Client, Reliable)
+       void ClientEffectApplied(UAbilitySystemComponent* AbilitySystemComponent, const FGameplayEffectSpec& EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle);

 };
diff --git a/Source/Aura/Public/Character/AuraCharacterBase.h b/Source/Aura/Public/Character/AuraCharacterBase.h
index 82f3a80..6b1091a 100644
--- a/Source/Aura/Public/Character/AuraCharacterBase.h
+++ b/Source/Aura/Public/Character/AuraCharacterBase.h
@@ -25,7 +25,8 @@ public:
 protected:
        virtual void BeginPlay() override;
        virtual void InitAbilityActorInfo() {}
-
+       virtual FVector GetCombatSocketLocation() override;
+
        void ApplyEffectToSelf(TSubclassOf<UGameplayEffect> GameplayEffectClass, float Level) const;
        void InitializeDefaultAttributes() const;

@@ -34,6 +35,9 @@ protected:
        UPROPERTY(EditAnywhere, Category = "Combat")
        TObjectPtr<USkeletalMeshComponent> Weapon;

+       UPROPERTY(EditAnywhere, Category = "Combat")
+       FName WeaponTipSocketName;
+
        UPROPERTY()
        TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;

diff --git a/Source/Aura/Public/Interaction/CombatInterface.h b/Source/Aura/Public/Interaction/CombatInterface.h
index 45fdaab..5e0591d 100644
--- a/Source/Aura/Public/Interaction/CombatInterface.h
+++ b/Source/Aura/Public/Interaction/CombatInterface.h
@@ -23,4 +23,5 @@ class AURA_API ICombatInterface
        // Add interface functions to this class. This is the class that will be inherited to implement this interface.
 public:
        virtual int32 GetPlayerLevel();
+       virtual FVector GetCombatSocketLocation();
 };
diff --git a/Source/Aura/Public/Player/AuraPlayerController.h b/Source/Aura/Public/Player/AuraPlayerController.h
index 8f1f331..8299b92 100644
--- a/Source/Aura/Public/Player/AuraPlayerController.h
+++ b/Source/Aura/Public/Player/AuraPlayerController.h
@@ -7,6 +7,7 @@
 #include "GameFramework/PlayerController.h"
 #include "AuraPlayerController.generated.h"

+class USplineComponent;
 class UAuraAbilitySystemComponent;
 class UAuraInputConfig;
 class IEnemyInterface;
@@ -41,6 +42,7 @@ private:
        void AbilityInputTagReleased(FGameplayTag InputTag);
        void AbilityInputTagHeld(FGameplayTag InputTag);

+       void AutoRun();
        UPROPERTY()
        TObjectPtr<UAuraAbilitySystemComponent> AuraAbilitySystemComponent;

@@ -53,6 +55,20 @@ private:
        UPROPERTY(EditDefaultsOnly, Category="Input")
        TObjectPtr<UAuraInputConfig> InputConfig;

+       FHitResult CursorHit;
+
        TScriptInterface<IEnemyInterface> LastActor;
        TScriptInterface<IEnemyInterface> ThisActor;
+
+       FVector CachedDestination = FVector::ZeroVector;
+       float FollowTime = 0.f;
+       float ShortPressThreshold = 0.5f;
+       bool bAutoRunning = false;
+       bool bTargeting = false;
+
+       UPROPERTY(EditDefaultsOnly)
+       float AutoRunAcceptanceRadius = 50.f;
+
+       UPROPERTY(VisibleAnywhere)
+       TObjectPtr<USplineComponent> Spline;
 };